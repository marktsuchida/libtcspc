/*
 * This file is part of libtcspc
 * Copyright 2019-2023 Board of Regents of the University of Wisconsin System
 * SPDX-License-Identifier: MIT
 */

#pragma once

#include "common.hpp"

#include <cmath>
#include <cstddef>
#include <cstring>
#include <exception>
#include <limits>
#include <optional>
#include <random>
#include <stdexcept>
#include <type_traits>
#include <utility>

namespace tcspc {

namespace internal {

template <typename TriggerEvent, typename TimingGenerator, typename Downstream>
class generate {
    using abstime_type = typename TimingGenerator::abstime_type;
    static_assert(
        std::is_same_v<abstime_type,
                       decltype(std::declval<TriggerEvent>().abstime)>);

    TimingGenerator generator;
    Downstream downstream;

    // Pred: bool(abstime_type const &)
    template <typename Pred> void emit(Pred predicate) {
        for (std::optional<abstime_type> t = std::as_const(generator).peek();
             t && predicate(*t); t = std::as_const(generator).peek()) {
            typename TimingGenerator::output_event_type e = generator.pop();
            downstream.handle(e);
        }
    }

  public:
    explicit generate(TimingGenerator &&generator, Downstream &&downstream)
        : generator(std::move(generator)), downstream(std::move(downstream)) {}

    void handle(TriggerEvent const &event) {
        emit([now = event.abstime](auto t) { return t < now; });
        generator.trigger(event);
        downstream.handle(event);
    }

    template <typename OtherTimeTaggedEvent>
    void handle(OtherTimeTaggedEvent const &event) {
        emit([now = event.abstime](auto t) { return t <= now; });
        downstream.handle(event);
    }

    void flush() {
        // Note that we do _not_ generate the remaining timings. Usually timing
        // events beyond the end of the event stream are not useful, and not
        // generating them means that infinite generators can be used.
        downstream.flush();
    }
};

} // namespace internal

/**
 * \brief Create a processor that generates a pattern of timing events in
 * response to a trigger.
 *
 * \ingroup processors-timing
 *
 * All events are passed through.
 *
 * Every time a \c TriggerEvent is received, generation of a pattern of timing
 * events is started according to the given \e generator.
 *
 * Timing events are generated just before an event with an equal or greater
 * abstime is passed through. In particular, timing events beyond the
 * last-passed-through event are not generated.
 *
 * If the next \c TriggerEvent is is received before the current pattern has
 * been completed, any remaining timing events in the pattern are suppressed
 * (including any that would have had the same abstime as the \c TriggerEvent).
 *
 * (If a timing event generated by the previous trigger shares the same abstime
 * as a new trigger, it will only be emitted if some other event (also with the
 * same abstime) is passed through before the new trigger. This usually makes
 * sense when the generated events are conceptually some kind of subdivision of
 * the trigger interval. In most applications, however, it is expected that the
 * next trigger is not received until a later abstime after all the timing
 * events in the previous series have been generated.)
 *
 * The type \c TimingGenerator must have the following members:
 *
 * - <tt>abstime_type</tt>, the integer type for absolute time,
 *
 * - <tt>output_event_type</tt>, the type of the generated event (which must
 *   have an \c abstime data member of type \c abstime_type),
 *
 * - <tt>void trigger(TriggerEvent const &event)</tt>, which starts a new
 *   iteration of timing generation, based on the abstime and other parameters
 *   of the trigger event,
 *
 * - <tt>auto peek() const noexcept -> std::optional<abstime_type></tt>, which
 *   returns the abstime of the next event to be generated, if any, and
 *
 * - <tt>auto pop() noexcept -> output_event_type</tt>, which generates the
 *   next event.
 *
 * It is guaranteed that \c pop is only called when \c peek returns an abstime.
 * However, \c peek must return the correct value (\c std::nullopt) even if \c
 * trigger has not yet been called. In other words, the generator must not
 * produce any events before the first time it is triggered.
 *
 * For timing generators provided by libtcspc, see \ref timing-generators.
 *
 * \tparam TriggerEvent event type that triggers a new round of timing
 * generation by resetting the timing generator
 *
 * \tparam TimingGenerator timing generator type
 *
 * \tparam Downstream downstream processor type
 *
 * \param generator the timing generator
 *
 * \param downstream downstream processor
 *
 * \return generate processor
 */
template <typename TriggerEvent, typename TimingGenerator, typename Downstream>
auto generate(TimingGenerator &&generator, Downstream &&downstream) {
    return internal::generate<TriggerEvent, TimingGenerator, Downstream>(
        std::forward<TimingGenerator>(generator),
        std::forward<Downstream>(downstream));
}

/**
 * \brief Timing generator that generates no output events.
 *
 * \ingroup timing-generators
 *
 * Timing generator for use with \ref generate.
 *
 * \tparam Event output event type (never generated)
 */
template <typename Event> class null_timing_generator {
  public:
    /** \brief Timing generator interface */
    using abstime_type = decltype(std::declval<Event>().abstime);

    /** \brief Timing generator interface */
    using output_event_type = Event;

    /** \brief Timing generator interface */
    template <typename TriggerEvent> void trigger(TriggerEvent const &event) {
        static_assert(std::is_same_v<decltype(event.abstime), abstime_type>);
    }

    /** \brief Timing generator interface */
    [[nodiscard]] auto peek() const noexcept -> std::optional<abstime_type> {
        return std::nullopt;
    }

    /** \brief Timing generator interface */
    auto pop() noexcept -> Event { internal::unreachable(); }
};

/**
 * \brief Timing generator that generates a single, delayed output event.
 *
 * \ingroup timing-generators
 *
 * Timing generator for use with \ref generate.
 *
 * \tparam Event output event type
 */
template <typename Event> class one_shot_timing_generator {
  public:
    /** \brief Timing generator interface */
    using abstime_type = decltype(std::declval<Event>().abstime);

  private:
    bool pending = false;
    abstime_type next = 0;
    abstime_type delay;

  public:
    /** \brief Timing generator interface */
    using output_event_type = Event;

    /**
     * \brief Construct with delay.
     *
     * \param delay how much to delay the output event relative to the trigger
     */
    explicit one_shot_timing_generator(abstime_type delay) : delay(delay) {
        if (delay < 0)
            throw std::invalid_argument(
                "one_shot_timing_generator delay must not be negative");
    }

    /** \brief Timing generator interface */
    template <typename TriggerEvent> void trigger(TriggerEvent const &event) {
        static_assert(std::is_same_v<decltype(event.abstime), abstime_type>);
        next = event.abstime + delay;
        pending = true;
    }

    /** \brief Timing generator interface */
    [[nodiscard]] auto peek() const noexcept -> std::optional<abstime_type> {
        if (pending)
            return next;
        return std::nullopt;
    }

    /** \brief Timing generator interface */
    auto pop() noexcept -> Event {
        Event event{};
        event.abstime = next;
        pending = false;
        return event;
    }
};

/**
 * \brief Timing generator that generates an equally spaced series of output
 * events.
 *
 * \ingroup timing-generators
 *
 * Timing generator for use with \ref generate.
 *
 * \tparam Event output event type
 */
template <typename Event> class linear_timing_generator {
  public:
    /** \brief Timing generator interface */
    using abstime_type = decltype(std::declval<Event>().abstime);

  private:
    abstime_type next = 0;
    std::size_t remaining = 0;

    abstime_type delay;
    abstime_type interval;
    std::size_t count;

  public:
    /** \brief Timing generator interface */
    using output_event_type = Event;

    /**
     * \brief Construct with delay, interval, and count.
     *
     * \param delay how much to delay the first output event relative to the
     * trigger (must be nonnegative)
     *
     * \param interval time interval between subsequent output events (must be
     * positive)
     *
     * \param count number of output events to generate for each trigger
     */
    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    explicit linear_timing_generator(abstime_type delay, abstime_type interval,
                                     std::size_t count)
        : delay(delay), interval(interval), count(count) {
        if (delay < 0)
            throw std::invalid_argument(
                "linear_timing_generator delay must not be negative");
        if (interval <= 0)
            throw std::invalid_argument(
                "linear_timing_generator interval must be positive");
    }

    /** \brief Timing generator interface */
    template <typename TriggerEvent> void trigger(TriggerEvent const &event) {
        static_assert(std::is_same_v<decltype(event.abstime), abstime_type>);
        next = event.abstime + delay;
        remaining = count;
    }

    /** \brief Timing generator interface */
    [[nodiscard]] auto peek() const noexcept -> std::optional<abstime_type> {
        if (remaining > 0)
            return next;
        return std::nullopt;
    }

    /** \brief Timing generator interface */
    auto pop() noexcept -> Event {
        Event event{};
        event.abstime = next;
        next += interval;
        --remaining;
        return event;
    }
};

namespace internal {

// Design note: We do not use std::uniform_real_distribution or
// std::generate_canonical, because they may have issues (may return the upper
// bound, depending on implementation). (Also, they do not produce the same
// sequence across library implementations.) Instead, we use our own method to
// produce random doubles in [0.0, 1.0).

// Formality: Check our assumption that 'double' is IEEE 754 double precision.
static_assert(std::numeric_limits<double>::is_iec559);
static_assert(std::numeric_limits<double>::radix == 2);
static_assert(std::numeric_limits<double>::digits == 53);

// Make a uniformly-distributed random double value in [0.0, 1.0), given a
// uniformly-distributed 64-bit random integer r (e.g. from std::mt19937_64).
[[nodiscard]] inline auto uniform_double_0_1(std::uint64_t r) noexcept
    -> double {
    // Keep the random bits in the 52-bit fraction field, but set the sign to
    // positive and exponent to 0 (giving a value in [1.0, 2.0)).
    r &= (1uLL << 52) - 1; // Keep only fraction
    r |= 1023uLL << 52;    // Exponent = 0
    double d{};
    std::memcpy(&d, &r, sizeof(d));
    return d - 1.0; // Will not produce subnormal values.
}

// Make a uniformly-distributed random double value in [0.0, 1.0), given a
// uniformly-distributed 32-bit random integer r from std::minstd_rand.
[[nodiscard]] inline auto uniform_double_0_1_minstd(std::uint32_t r) noexcept
    -> double {
    // Since r comes from std::minstd_rand, it is in [1, 2147483646].
    using minstd_type = decltype(std::minstd_rand0());
    static_assert(minstd_type::min() == 1);
    static_assert(minstd_type::max() == 2'147'483'646);
    // Do we care that 0 and 2^31-1 are not included in the range? Probably not
    // for dithering.
    assert(r < 2'147'483'648); // Do allow 0 and 2147483647 in tests.

    // 31 random bits should be plenty for our 1-dimensional dithering
    // purposes. Put the 31 random bits in the most significant part of the
    // 52-bit fraction field; leave the sign positive and exponent to 0 (giving
    // a value in [1.0, 2.0)).
    auto bits = std::uint64_t(r) << (52 - 31);
    bits |= 1023uLL << 52; // Exponent = 0
    double d{};
    std::memcpy(&d, &bits, sizeof(d));
    return d - 1.0; // Will not produce subnormal values.
}

template <typename T>
[[nodiscard]] inline auto dither(double value, double dither_noise) noexcept
    -> T {
    assert(dither_noise >= 0.0);
    assert(dither_noise < 1.0);
    return static_cast<T>(std::floor(value + dither_noise));
}

template <typename T> class dithering_quantizer {
    // Prefer std::minstd_rand() over std::mt19937[_64] because of its compact
    // state (the two have similar performance in a tight loop, but mt19937 has
    // > 2 KiB of state, which can become a nontrivial fraction of the L1D if
    // multiple instances are in use). The "poor" quality of the MINSTD PRNG is
    // likely not a significant issue for dithering purposes.
    // TODO Check if it actually makes any difference.
    std::minstd_rand prng;

  public:
    [[nodiscard]] auto operator()(double value) noexcept -> T {
        return dither<T>(value, uniform_double_0_1_minstd(prng()));
    }
};

} // namespace internal

/**
 * \brief Timing generator that generates an equally spaced series of output
 * events, with temporal dithering.
 *
 * \ingroup timing-generators
 *
 * Timing generator for use with \ref generate.
 *
 * \tparam Event output event type
 */
template <typename Event> class dithered_linear_timing_generator {
  public:
    /** \brief Timing generator interface */
    using abstime_type = decltype(std::declval<Event>().abstime);

  private:
    abstime_type trigger_time{};
    std::size_t remaining = 0;
    abstime_type next{};

    double offset;
    double interval;
    abstime_type interval_floor =
        static_cast<abstime_type>(std::floor(interval));
    std::size_t count;

    internal::dithering_quantizer<abstime_type> dithq;

    void compute_next() noexcept {
        if (remaining == 0)
            return;
        auto relnext =
            dithq(offset + interval * static_cast<double>(count - remaining));
        if (remaining < count) { // Clamp to interval floor-ceil.
            auto const relmin = next - trigger_time + interval_floor;
            auto const relmax = relmin + 1;
            relnext = relnext < relmin   ? relmin
                      : relnext > relmax ? relmax
                                         : relnext;
        }
        next = trigger_time + relnext;
    }

  public:
    /** \brief Timing generator interface */
    using output_event_type = Event;

    /**
     * \brief Construct with offset, interval, and count.
     *
     * \param offset how much to delay the first output event relative to the
     * trigger (must be nonnegative)
     *
     * \param interval time interval between subsequent output events (must be
     * positive)
     *
     * \param count number of output events to generate for each trigger
     */
    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    explicit dithered_linear_timing_generator(double offset, double interval,
                                              std::size_t count)
        : offset(offset), interval(interval), count(count) {
        if (offset < 0.0)
            throw std::invalid_argument(
                "dithered_linear_timing_generator offset must be non-negative");
        if (interval <= 0.0)
            throw std::invalid_argument(
                "dithered_linear_timing_generator interval must be positive");
    }

    /** \brief Timing generator interface */
    template <typename TriggerEvent> void trigger(TriggerEvent const &event) {
        static_assert(std::is_same_v<decltype(event.abstime), abstime_type>);
        trigger_time = event.abstime;
        remaining = count;
        compute_next();
    }

    /** \brief Timing generator interface */
    [[nodiscard]] auto peek() const noexcept -> std::optional<abstime_type> {
        if (remaining > 0)
            return next;
        return std::nullopt;
    }

    /** \brief Timing generator interface */
    auto pop() noexcept -> Event {
        Event event{};
        event.abstime = next;
        --remaining;
        compute_next();
        return event;
    }
};

/**
 * \brief Timing generator that generates a single, delayed output event whose
 * abstime is dithered.
 *
 * \ingroup timing-generators
 *
 * Timing generator for use with \ref generate.
 *
 * Note that the fact that this type is derived from \c
 * dithered_linear_timing_generator<Event> is an implementation detail and
 * should not be relied upon.
 *
 * \tparam Event output event type
 */
template <typename Event>
class dithered_one_shot_timing_generator
    : public dithered_linear_timing_generator<Event> {
  public:
    /**
     * \brief Construct with delay.
     *
     * \param delay how much to delay the output event relative to the trigger
     * (must not be negative)
     */
    explicit dithered_one_shot_timing_generator(double delay)
        : dithered_linear_timing_generator<Event>(delay, 1.0, 1) {}
};

} // namespace tcspc
